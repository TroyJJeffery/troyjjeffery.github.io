<!DOCTYPE html>
<html>
<head>
</head>

<title>Troy's GitHub - BlueJay</title>

<body>

<h1>Chapter 6</h1>

<p>
    <ol>
        <li><h3>Exercise 6.1</h3></li>
            <img src="Images/E.6.1.png" alt="" width=50%>

        <li><h3>Exercise 6.2</h3></li>
            Fields : <br>
            Constructors : Describes the different parameters Strings can be created with.<br>
            Method Summaries : The methods that can be used with the Class String by default.<br>
            Details : Details about the specific constructors and methods described above.

        <li><h3>Exercise 6.3</h3></li>

            startsWith(String prefix) : Tests the strings beginning and returns true if they are the same, false if not.<br>
            startsWith(String prefix, int toffset): Does the same as the other but allows you to choose an int to start that many characters in.

        <li><h3>Exercise 6.4</h3></li>

            endsWith(String suffix)

        <li><h3>Exercise 6.5</h3></li>
            length() : returns an int

        <li><h3>Exercise 6.6</h3></li>
            Most of them are named something that makes general sense.  I've also used some similar methods in python.<br>
            Pretty easy yeah.

        <li><h3>Exercise 6.7</h3></li>
            text.trim();

        <li><h3>Exercise 6.8</h3></li>
            <img src="Images/E.6.8.png" alt="" width=50%>

        <li><h3>Exercise 6.9</h3></li>
            <img src="Images/E.6.9.png" alt="" width=50%>

        <li><h3>Exercise 6.10</h3></li>
            boolean

        <li><h3>Exercise 6.11</h3></li>
            <img src="Images/E.6.11.png" alt="" width=50%>

        <li><h3>Exercise 6.12</h3></li>
            java.util.Random<br>
            An instance of this class is used to generate a stream of pseudorandom numbers.<br>
            public Random()<br>
            <pre>
                Random rnd = new Random();
                rnd.setSeet(seed);
            </pre>            

        <li><h3>Exercise 6.13</h3></li>
            <pre>
                import.util.Random

                public Random(){
                }
                
                public Random randomGenerator(){
                randomGenerator = new Random;
                int rnd = randomGenerator.nextInt();
                System.out.println(rnd);
                }
            </pre>

        <li><h3>Exercise 6.14</h3></li>
            <img src="Images/E.6.14.png" alt="" width=50%>
            <img src="Images/E.6.14.2.png" alt="" width=50%>
            <img src="Images/E.6.14.3.png" alt="" width=50%>

        <li><h3>Exercise 6.15</h3></li>
            A number from 0 - 100

        <li><h3>Exercise 6.16</h3></li>
            <img src="Images/E.6.16.png" alt="" width=50%>

        <li><h3>Exercise 6.17</h3></li>
            <img src="Images/E.6.17.png" alt="" width=50%>

        <li><h3>Exercise 6.18</h3></li>
            <img src="Images/E.6.18.png" alt="" width=50%>

        <li><h3>Exercise 6.19</h3></li>
            <img src="Images/E.6.19.png" alt="" width=50%>

        <li><h3>Exercise 6.20</h3></li>
            <img src="Images/E.6.20.png" alt="" width=50%>

        <li><h3>Exercise 6.21</h3></li>
            Well I mean it technically could but it would be overkill.<br>
            All the random methods we have on computers were made by human and are therefore not actually random.<br>
            If someone got their finger on the pulse of a random generator they could exploit it.<br>

        <li><h3>Exercise 6.22</h3></li>
            <img src="Images/E.6.22.png" alt="" width=50%>

        <li><h3>Exercise 6.23</h3></li>
            It will still work properly.  The method is set to check the size of the list and uses that as a max.

        <li><h3>Exercise 6.24</h3></li>
            HashMaps store values in key/value pairs.  Calling a key will return the value it's paired with.

        <li><h3>Exercise 6.25</h3></li>
        <pre>
        boolean containsKey(Object key): Used to return True if for a specified key, mapping is present in the map.
        boolean containsValue(Object value): Used to return true if one or more key is mapped to a specified value.
        Object get(Object key): It is used to retrieve or fetch the value mapped by a particular key.
        Object put(Object key, Object value): It is used to insert a particular mapping of key-value pair into a map.
        Object remove(Object key): It is used to remove the values for any particular key in the Map.
        </pre>

        <li><h3>Exercise 6.26</h3></li>
            (HashMap Name).size();

        <li><h3>Exercise 6.27</h3></li>
            <img src="Images/E.6.27.png" alt="" width=50%>

        <li><h3>Exercise 6.28</h3></li>
            It replaces the value that the key calls.

        <li><h3>Exercise 6.29</h3></li>
            There are now two entries, with unique keys, for whatever value.

        <li><h3>Exercise 6.30</h3></li>
            boolean containsKey(Object key):

        <li><h3>Exercise 6.31</h3></li>
            How would you search for a value without a key?  The key is a pre-requesite for the existence of the value.

        <li><h3>Exercise 6.32</h3></li>
           (HashMap name).keyset();

        <li><h3>Exercise 6.33</h3></li>
            <img src="Images/E.6.33.1.png" alt="" width=50%>
            <img src="Images/E.6.33.2.png" alt="" width=50%>
            <img src="Images/E.6.33.3.png" alt="" width=50%>
            <img src="Images/E.6.33.4.png" alt="" width=50%>
            <img src="Images/E.6.33.5.png" alt="" width=50%>


        <li><h3>Exercise 6.34</h3></li>
            ArrayLists and HashSets are similar in that they store lists of values.<br>
            They differ because ArrayLists use index numbers to call list items where HashSets use "keys"<br>
            ArrayLists and HashLists seem to be a bit more forgiving and allow more flexibility.

        <li><h3>Exercise 6.35</h3></li>
            It could cut each String at each space and enter that item into a list.<br>
            Then each item in the list could be run through a trim() process to remove the spaces<br>
            Maybe use some validation like when it finds a space it checks "if nextItem is " "" it trims the first space and checks again.<br>
            This would stop it from leaving empty Strings in your list from the ends of sentences or mistypes.

        <li><h3>Exercise 6.36</h3></li>
            you could probably do something like inputLine.split(" ", ":") and just keep adding spots to split.

        <li><h3>Exercise 6.37</h3></li>
            Items in a HashSet won't be orderered necessarily.  The order will be whatever order they were put in.  For a list <br>
            they'll have an actual order (index value) which can be manipulated.  HashSets don't give a fuck and do whatever they want.

        <li><h3>Exercise 6.38</h3></li>
            Not if we use the strategy I laid out in 6.35.  Dam dood pay attention.

        <li><h3>Exercise 6.39</h3></li>
            They're like a way of setting a value of all classes that are the same.  In the book they use the example of gravity<br>
            because gravity is always constant (in a certain context) there was no need to change that variable every time.<br>
            This allows only items of that class to access the variable without it becoming a Global variable which could cause lots of problems.<br>
            A real world example of this might be the license plate on your car. In America, every car has to have one (at least).<br>
            So as far as car dealers/manufacturers here are concerned  there must be a constant spot in the car "class" for them. <br>
            But just because cars have them does not mean bicycles do, so you wouldn't want to carry that variable over to that class.

        <li><h3>Exercise 6.40</h3></li>
            Well it looks like there's like a hundred.  They range from toStrings, to sorting methods, methods to add and remove etc.

        <li><h3>Exercise 6.41</h3></li>
            <img src="Images/E.6.41.1.png" alt="" width=50%>
            <img src="Images/E.6.41.2.png" alt="" width=50%>
            <img src="Images/E.6.41.3.png" alt="" width=50%>

        <li><h3>Exercise 6.42</h3></li>
            <img src="Images/E.6.42.1.png" alt="" width=50%>
            <img src="Images/E.6.42.2.png" alt="" width=50%>

        <li><h3>Exercise 6.43</h3></li>
            <img src="Images/E.6.43.1.png" alt="" width=50%>
            <img src="Images/E.6.43.2.png" alt="" width=50%>

        <li><h3>Exercise 6.44</h3></li>
            <img src="Images/E.6.44.png" alt="" width=50%>

        <li><h3>Exercise 6.45</h3></li>
            I'm not sure if this means keys or the value's they store.  None of my keys are the same....so good to go I guess?

        <li><h3>Exercise 6.46</h3></li>
            <img src="Images/E.6.46.png" alt="" width=50%>

        <li><h3>Exercise 6.47</h3></li>
            <img src="Images/E.6.47.png" alt="" width=50%>

        <li><h3>Exercise 6.48</h3></li>
            Checks to see if a key with that value already exists, if it does it does nothing. <br>
            If it doesn't, it will associate the item in that location on the HashMap. 

        <li><h3>Exercise 6.49</h3></li>
            <img src="Images/E.6.49.1.png" alt="" width=50%>
            <img src="Images/E.6.49.2.png" alt="" width=50%>

        <li><h3>Exercise 6.50</h3></li>


        <li><h3>Exercise 6.51</h3></li>


        <li><h3>Exercise 6.52</h3></li>


        <li><h3>Exercise 6.53</h3></li>


        <li><h3>Exercise 6.54</h3></li>


        <li><h3>Exercise 6.55</h3></li>


        <li><h3>Exercise 6.56</h3></li>


        <li><h3>Exercise 6.57</h3></li>


        <li><h3>Exercise 6.58</h3></li>


        <li><h3>Exercise 6.59</h3></li>


        <li><h3>Exercise 6.60</h3></li>

    </ol>
</p>
</body>
</html>
